\documentclass{beamer}

\usepackage{amssymb}
\usepackage{fancyvrb}
\usepackage{stmaryrd}
\usepackage{graphicx}
\usefonttheme{serif}


\newcommand{\Nat}{\mathbb{N}}

\SaveVerb{zer}=Z=
\SaveVerb{suc}=Succ n=
\SaveVerb{thr}=Succ (Succ (Succ Z))=
\SaveVerb{ele}=Succ (Succ (Succ (Succ (Succ (Succ (Succ (Succ (Succ (Succ (Succ Z))))))))))=
\SaveVerb{enn}=n=

\title{What About the Natural Numbers?}%\texorpdfstring{$\mathbb{N}$}}
\subtitle{JMCT}
\date{}

\usetheme{jmct}

\usepackage{calc}

\newcommand{\textover}[3][l]{%
 % #1 is the alignment, default l
 % #2 is the text to be printed
 % #3 is the text for setting the width
 \makebox[\widthof{#3}][#1]{#2}%
 }

\newcommand{\blueit}[1]{%
  {\color{dark-lucid-blue}#1}%
}
\newcommand{\blueite}[1]{%
  \blueit{\emph{#1}}%
}


\newcommand{\myquote}[3]{
  ``#1''
  \vspace{3pt}
  \hrule
  \begin{flushright}
  --- \blueit{\emph{#2}}, \emph{#3}
  \end{flushright}
}

\begin{document}
	\frame {
		\titlepage
	}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
%%% Intro
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 

  \frame {
    \centering {\fontsize{88}{68}\selectfont $\mathbb{N}$\phantom{?}}
  }
  \frame {
    \centering {\fontsize{88}{68}\selectfont $\mathbb{N}$?}
  }


  \frame {
    \myquote{Some thirty years into the history of
      machine-independent programming language design, the treatment of numbers
      is still problematic.}{Colin Runciman}{1989}
  }
  \frame {
    \myquote{Some \textover[c]{\blueit{sixty}}{thirty} years into the history of
      machine-independent programming language design, the treatment of numbers
      is still problematic.}{Me}{just now}
  }
  \frame{
    \frametitle{Main takeaway}
    The number system we use should relate to the structures of the problem
    we're solving.
  }
  \frame{
    \frametitle{Main takeaway}
    For some domains, the use of Reals\footnote{or their approximation via
    \texttt{Float}s} may be appropriate:
    \begin{itemize}
      \item<2 -> e.g. physics calculations involving volume, speed, or mass
    \end{itemize}
  }
  \frame{
    \frametitle{Main takeaway}
    \emph{Many} problems \blueit{Integers} are appropriate:
    \begin{itemize}
      \item<2 -> Fixed-precision DSP
      \item<3 -> Bank account balance :'(
    \end{itemize}
  }
  \frame{
    \frametitle{Main takeaway}
    Runciman's argument:\newline
    \hangindent=0.7cm
    For many of the discrete structures involved in the
    day-to-day practice of programming, the \blueit{natural} numbers are
    the most appropriate number system.
  }
  \frame{
    \frametitle{How?}
    In the process of exploring the Natural Numbers, we'll be developing an API.
    As we progress we'll see how different representations affect our API.
  }

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
%%% Outline
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 

      %* Overview of the $\mathbb{N}$s themselves
      %* Programming with \texttt{Nat}
      %* Arithmetic with \texttt{Nat} and properties we care about
      %* How does \texttt{Nat} influence API design?
      %* Beyond \texttt{Nat}
      %* Conclude

  %%%%%%%
  % Goals
  %
  \frame{
    \frametitle{\#goals}
    \begin{enumerate}
      \item<2 -> Show you that the [lazy?] $\mathbb{N}$s are \blueite{Good}
                 and \blueite{Proper}
      \item<3 -> Demonstrate that even \emph{simple} choices of types
                 for an API have deep consequences
      \item<4 -> Have you asking ``What about the Natural Numbers?''
                 next time you create an API.
    \end{enumerate}
  }
  %%%%%%%
  % Actual Outline
  %
  \frame{
    \frametitle{Shape of things to come}
    \begin{enumerate}
      \item<2 -> Overview of the $\mathbb{N}$s themselves
      \item<3 -> Programming with \texttt{Nat}
      \item<4 -> Arithmetic with \texttt{Nat} and properties we care about
      \item<5 -> How does \texttt{Nat} influence API design?
      \item<6 -> Beyond \texttt{Nat}
      \item<7 -> Conclude
    \end{enumerate}
  }

  %%%%%%%
  % What are they?
  %
  % We actually see them here! We just counted things, _that's_
  % the natural number.
  \frame{
    \frametitle{What \emph{are} they?}
    The \emph{Natural} numbers have a few definitions:
    \begin{enumerate}
      \item<2-> Set Theoretic
      \item<3> Peano Axioms
    \end{enumerate}
  }

  %%%%%%%
  % Set Theoretic
  %
  \frame{
    \frametitle{\textbf{\underline{Set}}ting Yourself Up For Success}
  }
  \frame{
    \frametitle{\textbf{\underline{Set}}ting Yourself Up For Success}

    Several possible Set-theoretic definitions, von Neumann proposed the
    following:
    \begin{itemize}
      \item<2 -> $0 = \{\}$
      \item<3 -> $1 = 0 \cup \{0\}$
      \item<4  > $2 = 1 \cup \{1\}$
    \end{itemize}
  }
  \frame{
    \frametitle{\textbf{\underline{Set}}ting Yourself Up For Success}

    Several possible Set-theoretic definitions, von Neumann proposed the
    following:
    \begin{itemize}
      \item<1 -> $0 = \{\}$
      \item<1 -> $1 = 0 \cup \{0\} = \{0\} = \{\{\}\}$
      \item<1  > $2 = 1 \cup \{1\} = \{0,1\} = \{\{\},\{\{\}\}\}$
    \end{itemize}
  }

  %%%%%%%
  % Peano Axioms
  %
  % That's pretty complicated
  %
  % Turns our that there is a simpler way
  \frame{
    \frametitle{\textbf{\underline{Set}}ting Yourself Up For Success}

    \centering {\huge oof}

  }
  \frame{
    \frametitle{Setting Yourself Up For \textbf{\underline{Succ}}ess}

    In 1889 Giuseppe Peano published\par
    \vspace{0.5cm}

    ``The principles of arithmetic presented by a new method''

  }
  \frame{
    \frametitle{Setting Yourself Up For \textbf{\underline{Succ}}ess}

    The two axioms we care about most (right now) are simple enough:
    \begin{itemize}
      \item <2 -> $0 \in \mathbb{N}$
      \item <3 -> $\forall n \in \Nat\ldotp S(n) \in \Nat$
    \end{itemize}

  }

  %%%%%%%
  % Data!
  %
  \frame{
    \frametitle{Setting Yourself Up For \textbf{\underline{Succ}}ess}

    Okay, but we're concerned with the \emph{practice} of \emph{programming} \dots
  }
  \begin{frame}[fragile]
    \frametitle{Setting Yourself Up For \textbf{\underline{Succ}}ess}
    \begin{figure}
    {\color{dark-gray}
      \centering
\begin{BVerbatim}
 type Nat where
   Z    : Nat
   Succ : Nat -> Nat
\end{BVerbatim}
    }
    \end{figure}
  \end{frame}
  \begin{frame}[fragile]
    \frametitle{Setting Yourself Up For \textbf{\underline{Succ}}ess}
    Now we can easily represent any $\Nat$ we want!
    {\color{dark-gray}
      \begin{align*}
      \hfill \\
      \hfill
      \end{align*}
    }
  \end{frame}
  \begin{frame}[fragile]
    \frametitle{Setting Yourself Up For \textbf{\underline{Succ}}ess}
    Now we can easily represent any $\Nat$ we want!
    {\color{dark-gray}
      \begin{align*}
      \llbracket \UseVerb{zer} \rrbracket &= \blueit{0}\\
      \llbracket \UseVerb{suc} \rrbracket &= \blueit{1~+~} \llbracket \UseVerb{enn} \rrbracket
      \end{align*}
    }
  \end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
%%% Construction
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 

  \frame{
    \frametitle{Talk over?}
    This is all very nice and elegant, but the ergonomics \emph{suck}
  }

  \begin{frame}[fragile]
    \frametitle{RSI risk}
    Even just typing this slide made my RSI flare up:
    \begin{itemize}
      \item $\blueit{3}  \Rightarrow $ {\color{dark-gray}\UseVerb{thr}}
      \item $\blueit{11} \Rightarrow $ {\color{dark-gray}\UseVerb{ele}}
    \end{itemize}
  \end{frame}

  %%%%%%%
  % Our friend, the list!
  %
  \frame{
    \frametitle{Spoonful of sugar}
    What do we do for other types?
  }
  \begin{frame}[fragile]
    \frametitle{Spoonful of sugar}
    \begin{figure}
    {\color{dark-gray}
      \centering
\begin{BVerbatim}
 type List elem where
   []   : List elem
   (::) : elem -> List elem -> List elem
\end{BVerbatim}
    }
    \end{figure}
  \end{frame}
  \begin{frame}[fragile]
    \frametitle{Spoonful of sugar}
    Lists are flexible and easy to reason about, but they have the same problem!
    \begin{itemize}
      \item<2 -> {\color{dark-gray} \verb-type String = List Char-}
      \item<3  > {\color{dark-gray} \verb-initials = 'P' :: ('W' :: ('L' :: []))-}
    \end{itemize}
  \end{frame}
  \begin{frame}[fragile]
    \frametitle{Spoonful of sugar}
    Because of this ubiquity of lists, compiler writers quickly came up with syntactic sugar for them:
    \begin{itemize}
      \item<2 -> {\color{dark-gray} \verb-"PWL"- $\Rightarrow$ \verb-'P' :: ('W' :: ('L' :: []))-}
      \item<3  > {\color{dark-gray} \verb-[1..3]- $\Rightarrow$ \verb-'1' :: ('2' :: ('3' :: []))-}
    \end{itemize}
  \end{frame}
  \begin{frame}[fragile]
    \frametitle{Spoonful of sugar}
    Similarly, we can implement syntactic sugar for the natural numbers:
    \begin{itemize}
      \item<2 -> {\color{dark-gray} \verb-3- $\Rightarrow$ \UseVerb{thr}}
    \end{itemize}
  \end{frame}
  %%%%%%%
  % We still maintain our reasoning power
  %
  \frame{
    \frametitle{Spoonful of sugar}
    We lose nothing with the syntactic sugar, we can still pattern match on naturals and
    retain all of our inductive reasoning.
  }
  \begin{frame}[fragile]
    \frametitle{Natural usage}
    \begin{figure}
    {\color{dark-gray}
      \centering
\begin{BVerbatim}
    ... if length xs <= 5
        then ...
        else ...
\end{BVerbatim}
    }
    \end{figure}
  \end{frame}
  \begin{frame}[fragile]
    \frametitle{Pattern Matching still available...}
    \begin{figure}
    {\color{dark-gray}
      \centering
\begin{BVerbatim}
(<=) : Nat -> Nat -> Bool
Z               _ = True
(Succ _)        Z = False
(Succ x) (Succ y) = x <= y
\end{BVerbatim}
    }
    \end{figure}
  \end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
%%% Arithmetic
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 

  \frame{
    \frametitle{Reading, Writing and ...}
    \begin{enumerate}
      \item<2 -> Programmers expect some arithmetic `out of the box'
                  when dealing with numbers.
      \item<3 -> At the very least they expect \blueit{$+$}, \blueit{$-$}, \blueit{$\times$}, \blueit{$\div$}
    \end{enumerate}
  }
  \frame{
    \frametitle{Real data structures}
    When programming with the discrete structures which are common in programming,
    there is a correspondence between the operations on numbers and the operations
    on the data structures.
    \begin{enumerate}
      \item<2 -> Think `array indices', or `size'
      \item<3 -> What would a \blueite{negative} size mean?
    \end{enumerate}
  }
  \frame{
    \frametitle{Who would even do that?}
  }
  \frame{
    \frametitle{Who would even do that?}
    \begin{figure}
      \centering
      \includegraphics[width=0.5\textwidth]{figs/length.png}
      \caption{lol}
    \end{figure}
  }
  \frame{
    \frametitle{Exceptional negatives}
    Think of how many APIs return an ``\blueit{\texttt{Int}}''.
    \begin{enumerate}
      \item <2> How many of these APIs only use the negative numbers to signal errors?
    \end{enumerate}
  }
  \frame{
    \frametitle{What do we want?}
    If we think a bit about arithmetic we may conclude the following:
    \begin{enumerate}
      \item<2 -> Ideally, our operators would be \blueite{total}
      \item<3 -> When possible, we want our operators to be \blueite{closed}
    \end{enumerate}
  }
  \begin{frame}[fragile]
    \frametitle{Why?}
    These properties, when combined, allow us to be confident that when we
    operate on two \verb-Nat-s, we get another \verb-Nat-.
    \begin{enumerate}
      \item<2 -> This isn't true for arithmetic over all number systems (nor should it be!)
      \item<3 -> Many languages fail even where it should be!
    \end{enumerate}
  \end{frame}
  \frame{
    \frametitle{Totality}
    Our functions being \blueite{total} gives us confidence that for any input, we
    get a result.
  }
  \frame{
    \frametitle{Closure}
    Our functions being \blueite{closed} means that the result values lie within the
    same number system as their arguments.
  }
  \frame{
    \frametitle{What do we want? (part 2)}
    \myquote{The aim is a total closed system of arithmetic with results that
             can be safely interpreted in the context of the discrete
             structures in general programming}{Colin Runciman}{1989}
  }
  \frame{
    \frametitle{Back to arithmetic}
    Addition and Multiplication present no difficulties.
  }
  \frame{
    \frametitle{Back to arithmetic}
    What about Subtraction?
  }
  \begin{frame}[fragile]
    \frametitle{Don't wait, saturate}
    \begin{figure}
    {\color{dark-gray}
      \centering
\begin{BVerbatim}
(.-.) : Nat -> Nat -> Nat
n        .-.        Z = n
Z        .-.        _ = Z
(Succ n) .-. (Succ m) = n .-. m
\end{BVerbatim}
    }
    \end{figure}
  \end{frame}
  \frame{
    \frametitle{Relate back to data structures}
  }
  \begin{frame}[fragile]
    \frametitle{Relate back to data structures}
    \begin{figure}
    {\color{dark-gray}
      \centering
\begin{BVerbatim}
drop : Nat -> List a -> List a
drop Z        xs      = xs
drop _        []      = []
drop (Succ n) (x::xs) = drop n xs
\end{BVerbatim}
    }
    \end{figure}
  \end{frame}
  \begin{frame}[fragile]
    \frametitle{Relate back to data structures}
    We \emph{want} a correspondence between operations on data structures and
    on numbers:
    \begin{figure}
    {\color{dark-gray}
      \centering
\begin{BVerbatim}
length (drop n xs) === length xs .-. n
\end{BVerbatim}
    }
    \end{figure}
  \end{frame}
  \frame{
    \frametitle{Relate back to data structures}
    These sorts of correspondences are what we use (often in our head) when
    programming or refactoring.
  }
  \frame{
    \frametitle{A divisive issue}
    Unlike Subtraction, division is \emph{already} closed over Natural Numbers
  }
  \frame{
    \frametitle{A divisive issue}
    Unlike Subtraction, division is \emph{already} closed over Natural Numbers
    (for the cases for which it is defined!)
  }
  \frame{
    \frametitle{Back to square zero}
    Some mathematicians define the Natural Numbers as starting from One! Would
    that save us from this issue?
  }
  \frame{
    \frametitle{Back to square zero}
    Maybe, but then we'd lose the important correspondence with real data
    structures.
  }
  \frame{
    \frametitle{Quick digression}
  }
  \frame{
    \frametitle{Quick digression}
    Zero is not nothing!
  }
  \frame{
    \frametitle{Two solutions}
    Runciman proposes two solutions to the `division by zero' problem:
    \begin{enumerate}
      \item<2 -> based on viewing division on $\mathbb{N}$s as `slicing'
      \item<3 -> based on using lazy \texttt{Nat}s
    \end{enumerate}
  }
  \frame{
    \frametitle{Division as slicing}
    Think of dividing \texttt{x} by \texttt{y} as cutting \texttt{x} in
    \texttt{y} places.
  }
  \begin{frame}[fragile]
    \frametitle{Division as slicing}
    We can write a total division, \texttt{//}, in terms of a partial (fails when dividing by zero)
    division, \texttt{/}:
    \begin{figure}
    {\color{dark-gray}
      \centering
\begin{BVerbatim}
x // y = x / (Succ y)
\end{BVerbatim}
    }
    \end{figure}
  \end{frame}
  \begin{frame}[fragile]
    \frametitle{Division as slicing}
    We can write a total division, \texttt{//}, in terms of a partial (fails when dividing by zero)
    division, \texttt{/}:
    \begin{figure}
    {\color{dark-gray}
      \centering
\begin{BVerbatim}
x // y = x / (Succ y)
\end{BVerbatim}
    }
    \end{figure}
  \end{frame}
  \frame{
    \frametitle{Umm...}
    We get one intuitive property
    \begin{itemize}
      \item<2 -> Slicing zero times gets you the original thing back
    \end{itemize}
  }
  \frame{
    \frametitle{... that's wrong}
    At the cost of it being correct at every other \texttt{Nat}
  }
  \begin{frame}[fragile]
    \frametitle{Let's fix it}
    We get back correctness by subtracting $1$ from the divisor before passing it
    \texttt{//}
    \begin{figure}
    {\color{dark-gray}
      \centering
\begin{BVerbatim}
x ./. y = x // (y .-. 1)
\end{BVerbatim}
    }
    \end{figure}
  \end{frame}
  \frame{
    \frametitle{You coward!}
    In a sense we've only side-stepped the problem!
    \begin{itemize}
      \item<2 -> If you think this is the lazy solution...
    \end{itemize}
  }

    
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
%%% Conclusion
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 

  \frame{
    \frametitle{Smash that subscribe button}
      Thanks for your time!

      You can read more of my rants \blueit{@josecalderon}
  }

  \frame {
    \centering {\fontsize{88}{68}\selectfont $\mathbb{N}$!}
  }

\end{document}
